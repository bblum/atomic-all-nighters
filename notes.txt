group-00
	start-time 1322
	had to change do { } while (0) macros to static inline functions
	need an EXIT_NESTED_AND_SLEEP / EXIT_AND_SLEEP
		hack around to change by making disable interrupts nested
	found missing argument in func prototype
		"pcb_t* new_child_process()"
		"general_fault_handler()"
		reap_exited_process() status_ptr
	argh, sanity.c is deadcode
	
	false positive: printf os shutting down with interrupts off

	pause time 1514
	resume time 1528

	need a magic annotation for the enable interrupts

	BUG #1: key handler takes a mutex before acknowledging interrupt
	BUG #2: add_to_runnable_tid doesn't reenable in all cases

	TRUSTMEs used (except enums and casting):
		DISABLE/ENABLE_INTERRUPTS, kernel_main, acknowledge_interrupt

	pause time 1558
	resume time 1635
	end 1642
	start 1408
	end 1412

group-01
	start-time 2053

	AAN needs to parse enums to get idents!
	false negative: sem_signal in kbd handler after EXIT_ATOMIC readchar
		but before acknowledge_interrupt
	hafta use a trustme in sem_signal; a better tool could cope

	BUG: schedule(DESCHEDULE) leaks interrupts

	False positive: mutex_unlock() after disable_interrupts() in deschedule

	TRUSTMEs used (except enums and casting):
		putbytes, sem_signal, kernel_main, acknowledge_interrupt

	stop-time 2255
	start-time 1418
	stop-time 1422

group-02
	start-time 1610
	stop 1615
	start 1619
	stop 1621
	start 1622
	stop 1626
	start 1632
	stop 1634
	start 1638
	stop 1653
	start 1721
	stop 1724
	start 1725
	stop 1729
	start 1732
	stop 1738
	start 1854
	stop 1914
	start 1925
	stop 1927
	start 2040
	stop 2059
	start 2106
	stop 2131
	start 2145
	stop 2153
	start 2226
	stop 2228

	BUG (moderate?): if !intr_ok, kbd forgets to return

	BUG(severe): sleep_pop in timer handler unsafe

	false positive in sleep.c/sleep.c (2 errors)
		sleep_add can return with different contexts intentionally
	false positive in readline (2 warnings + 2 errors)
		cpu_relax returns with interrupts off intentionally just here

	start 1423
	stop 1430

group-03
	start-time 1034
	stop-time 1055
	start-time 1119
	stop-time 1217
	start-time 1219
	stop-time 1220
	start-time 1432
	stop-time 1433
	start-time 1431
	stop-time 1437

	false positive in readline (1 warning, 1 error)
		run_descheduled has an if statement that's always true
	bugs 0
	
group-04
	start-time 1244
	stop-time 1335

	aan misfeature: anonymous unions
	aan misfeature: labels leak interfunction

	start-time 2043
	stop-time 2121

	BUG(severe): kmutex_lock after disable_interrupts in vanish can U-A-F
	false positives 0

group-06
	start-time 1058
	stop-time 1144

	BUG(severe): append_tcb mutex_lock in context switch returns with
	interrupts on
	false positives 0

	refactor a "if (c) disable; ... if (c) enable;" pattern

group-07
	start-time 1251
	stop-time 1357
	start-time 1740

	false positive: both enable_interrupts and enable_preempt
	false positive (2 errors): interrupts were off needlessly in wait
	false positive (3 errors): interrupts were off needlessly in run_reaper
	false positive (1 error): atomic deschedule relies on internal vm impl details

	end-time 1759

	BUG: two waiting threads can race on a write_to_user schedule

group-08
	start-time 1801
	stop-time 1855
	start-time 1025
	stop-time 1035

	false positive (1 warning): conditional disable interrupts OK in
	BUG(minor): schedule_specific_thread leaks interrupts
	BUG(minor): deschedule_current_thread leaks interrupts

mkdir /tmp/shit; for i in `find | grep '\.c$\|\.h$'`; do echo "#include <aan.h>" >> /tmp/shit/`basename $i`; cat $i >> /tmp/shit/`basename $i`; mv /tmp/shit/`basename $i` $i; done; rmdir /tmp/shit
